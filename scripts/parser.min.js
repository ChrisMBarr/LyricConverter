/*!
 * LICENSE:
 * CC BY-NC-SA 3.0
 * This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
 * http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US
 */
 
var parser = (function(){

	var utilities = {
		decode: function(str){
			var decoded = window.atob( str );
			try{
				return decodeURIComponent(escape(decoded));
			}catch(ex){
				return decoded;
			}
		},
		encode:function(str){
			return window.btoa(unescape(encodeURIComponent( str )));
		}
	}

	function parseFile(i, fileObj){
		var data = fileObj.data;
		var fullFileName = fileObj.name;

		try{
			//Find the file extention
			var fileParts = fullFileName.split(".");
			var fileName = fileParts[0];
			var fileExt = fileParts.slice(-1)[0].toLowerCase();

			//Test the file extension with the test function registered with each format type
			//When one matches, use that formats convert function
			var convertFn;
			$.each(parser.formats, function(format, formatObj){
				if(formatObj.testExtension(fileExt)){
					convertFn = formatObj.convert;
					return false;
				}
			});

			//Make sure the convert function exists...
			if($.isFunction(convertFn)){
				//Browsers will add some unneeded text to the base64 encoding. Remove it.
				var encodedSongData = data.replace(/^data:.*;base64,/,"");
				var decodedSongData = utilities.decode(encodedSongData);

				//Pass the decoded song date to the convert function
				//We will get back a normalized version of the song content for the supported file type
				parser.songList.push({
					name: fileName,
					data: convertFn(decodedSongData, fileName)
				});

			}else{
				parser.errorList.push("The file <strong>"+fullFileName+"</strong> cannot be parsed because <strong>."+fileExt.toUpperCase()+"</strong> files are not supported!")
			}
		}catch(ex){
			//console.error(ex);
			parser.errorList.push("There was an error reading the file <strong>"+fullFileName+"</strong>");
		}
	}

	function complete($outputContainer){
		if(parser.songList.length){
			//Pass the final song data to the selected output type
			parser.outputs[parser.outputFormat]($outputContainer, parser.songList);
		}
	}

	return {
		//Expose functions publicly
		utilities: utilities,
		parseFile: parseFile,
		complete: complete,
		outputFormat: null,
		
		//UI properties should be filled in when this is run
		displayError: null,
		songList:[],
		errorList:[],

		//These objects will be filled in when formatter & output files are run
		formats:{},
		outputs:{}
	}
})();

/* **********************************************
     Begin jquery.fileDragAndDrop.js
********************************************** */

(function($){
	var _exitTimer = null;

	// jQuery plugin initialization
	$.fn.fileDragAndDrop = function (options) {

		//If a function was passed in instead of an options object,
		//just use this as the onFileRead options instead
		if($.isFunction(options)){
			var o = {};
			o.onFileRead = options;
			options=o; 
		}

		//Return the elements & loop though them
		return this.each(function(){
			var $dropArea = $(this);
			
			//Create a finalized version of the options
			var opts = opts = $.extend({}, $.fn.fileDragAndDrop.defaults, options);

			//If this option was not set, make it the same as the drop area
			if (opts.addClassTo.length===0){
				opts.addClassTo = $dropArea;
			}

			//can't bind these events with jQuery!
			this.addEventListener('dragenter', function(ev){
				_events._over(ev, $dropArea, opts);
			}, false);
			this.addEventListener('dragover', function(ev){
				_events._exit(ev, $dropArea, opts);
			}, false);
			this.addEventListener('drop', function(ev){
				_events._drop(ev, $dropArea, opts);
			}, false);
		});
	};

	$.fn.fileDragAndDrop.defaults = {
		overClass: "over",
		addClassTo: $([]),
		onFileRead: null
	};

	var _events = {
		_over : function(ev, $dropArea, opts){
			$(opts.addClassTo).addClass(opts.overClass);
			_stopEvent(ev);
		},
		_exit : function(ev, $dropArea, opts){
			clearTimeout(_exitTimer);
			_exitTimer=setTimeout(function(){
				$(opts.addClassTo).removeClass(opts.overClass);
			},100);
			_stopEvent(ev);
		},
		_drop : function(ev, $dropArea, opts){
			$(opts.addClassTo).removeClass(opts.overClass);
			_stopEvent(ev);
			var fileList = ev.dataTransfer.files;

			//Create an array of file objects for us to fill in
			var fileArray = [];

			//Loop through each file
			for(var i = 0; i <= fileList.length; i++){

				//Create a new file reader to read the file
				var reader = new FileReader();

				//Create a closure so we can properly pass in the file information since this will complete async!
				var completeFn = (_handleFile)(fileList[i], fileArray, fileList.length, opts);

				//Different browsers impliment this in different ways, but call the complete function when the file has finished being read
				if(reader.addEventListener) {
					// Firefox, Chrome
					reader.addEventListener('loadend', completeFn, false);
				} else {
					// Safari
					reader.onloadend = completeFn;
				}

				//Actually read the file
				reader.readAsDataURL(fileList[i]);
			}
		}
	};

	//This is the complete function for reading a file,

	function _handleFile(theFile, fileArray, fileCount, opts) {
		//When called, it has to return a function back up to the listener event
		return function(ev){
			//Add the current file to the array
			fileArray.push({
				name: theFile.name,
				size: theFile.size,
				type: theFile.type,
				lastModified: theFile.lastModifiedDate,
				data: ev.target.result
			});
			
			//Once the correct number of items have been put in the array, call the completion function		
			if(fileArray.length == fileCount && $.isFunction(opts.onFileRead)){
				opts.onFileRead(fileArray, opts)
			}
		}
	}

	function _handleReaderLoadEnd(ev, fullFileName, opts) {
		var data = ev.target.result;
		if(data.length>1 && $.isFunction(opts.onFileRead)){
			opts.onFileRead(data, fullFileName)
		}
	}

	function _stopEvent(ev){
		ev.stopPropagation();
		ev.preventDefault();
	}
})(jQuery);

/* **********************************************
     Begin FileSaver.js
********************************************** */

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2013-01-23
 * 
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  || (navigator.msSaveBlob && navigator.msSaveBlob.bind(navigator))
  || (function(view) {
	"use strict";
	var
		  doc = view.document
		  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, URL = view.URL || view.webkitURL || view
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		, deletion_queue = []
		, process_deletion_queue = function() {
			var i = deletion_queue.length;
			while (i--) {
				var file = deletion_queue[i];
				if (typeof file === "string") { // file is an object URL
					URL.revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			}
			deletion_queue.length = 0; // clear queue
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, get_object_url = function() {
					var object_url = get_URL().createObjectURL(blob);
					deletion_queue.push(object_url);
					return object_url;
				}
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_object_url(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_object_url(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			} else {
				target_view = view.open();
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									deletion_queue.push(file);
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;
	
	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;
	
	view.addEventListener("unload", process_deletion_queue, false);
	return saveAs;
}(self));


/* **********************************************
     Begin jszip.js
********************************************** */

/**

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2012 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See LICENSE.markdown.

Usage:
   zip = new JSZip();
   zip.file("hello.txt", "Hello, World!").file("tempfile", "nothing");
   zip.folder("images").file("smile.gif", base64Data, {base64: true});
   zip.file("Xmas.txt", "Ho ho ho !", {date : new Date("December 25, 2007 00:00:01")});
   zip.remove("tempfile");

   base64zip = zip.generate();

**/

/**
 * Representation a of zip file in js
 * @constructor
 * @param {String=|ArrayBuffer=|Uint8Array=} data the data to load, if any (optional).
 * @param {Object=} options the options for creating this objects (optional).
 */
var JSZip = function(data, options) {
   // object containing the files :
   // {
   //   "folder/" : {...},
   //   "folder/data.txt" : {...}
   // }
   this.files = {};

   // Where we are in the hierarchy
   this.root = "";

   if (data) {
      this.load(data, options);
   }
};

JSZip.signature = {
   LOCAL_FILE_HEADER : "\x50\x4b\x03\x04",
   CENTRAL_FILE_HEADER : "\x50\x4b\x01\x02",
   CENTRAL_DIRECTORY_END : "\x50\x4b\x05\x06",
   ZIP64_CENTRAL_DIRECTORY_LOCATOR : "\x50\x4b\x06\x07",
   ZIP64_CENTRAL_DIRECTORY_END : "\x50\x4b\x06\x06",
   DATA_DESCRIPTOR : "\x50\x4b\x07\x08"
};

// Default properties for a new file
JSZip.defaults = {
   base64: false,
   binary: false,
   dir: false,
   date: null,
   compression: null
};


JSZip.prototype = (function () {
   /**
    * A simple object representing a file in the zip file.
    * @constructor
    * @param {string} name the name of the file
    * @param {string} data the data
    * @param {Object} options the options of the file
    */
   var ZipObject = function (name, data, options) {
      this.name = name;
      this.data = data;
      this.options = options;
   };

   ZipObject.prototype = {
      /**
       * Return the content as UTF8 string.
       * @return {string} the UTF8 string.
       */
      asText : function () {
         var result = this.data;
         if (result === null || typeof result === "undefined") {
            return "";
         }
         if (this.options.base64) {
            result = JSZipBase64.decode(result);
         }
         if (this.options.binary) {
            result = JSZip.prototype.utf8decode(result);
         }
         return result;
      },
      /**
       * Returns the binary content.
       * @return {string} the content as binary.
       */
      asBinary : function () {
         var result = this.data;
         if (result === null || typeof result === "undefined") {
            return "";
         }
         if (this.options.base64) {
            result = JSZipBase64.decode(result);
         }
         if (!this.options.binary) {
            result = JSZip.prototype.utf8encode(result);
         }
         return result;
      },
      /**
       * Returns the content as an Uint8Array.
       * @return {Uint8Array} the content as an Uint8Array.
       */
      asUint8Array : function () {
         return JSZip.utils.string2Uint8Array(this.asBinary());
      },
      /**
       * Returns the content as an ArrayBuffer.
       * @return {ArrayBuffer} the content as an ArrayBufer.
       */
      asArrayBuffer : function () {
         return JSZip.utils.string2Uint8Array(this.asBinary()).buffer;
      }
   };

   /**
    * Transform an integer into a string in hexadecimal.
    * @private
    * @param {number} dec the number to convert.
    * @param {number} bytes the number of bytes to generate.
    * @returns {string} the result.
    */
   var decToHex = function(dec, bytes) {
      var hex = "", i;
      for(i = 0; i < bytes; i++) {
         hex += String.fromCharCode(dec&0xff);
         dec=dec>>>8;
      }
      return hex;
   };

   /**
    * Merge the objects passed as parameters into a new one.
    * @private
    * @param {...Object} var_args All objects to merge.
    * @return {Object} a new object with the data of the others.
    */
   var extend = function () {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
         for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
               result[attr] = arguments[i][attr];
            }
         }
      }
      return result;
   };

   /**
    * Transforms the (incomplete) options from the user into the complete
    * set of options to create a file.
    * @private
    * @param {Object} o the options from the user.
    * @return {Object} the complete set of options.
    */
   var prepareFileAttrs = function (o) {
      o = o || {};
      if (o.base64 === true && o.binary == null) {
         o.binary = true;
      }
      o = extend(o, JSZip.defaults);
      o.date = o.date || new Date();
      if (o.compression !== null) o.compression = o.compression.toUpperCase();

      return o;
   };

  /**
   * Add a file in the current folder.
   * @private
   * @param {string} name the name of the file
   * @param {String|ArrayBuffer|Uint8Array} data the data of the file
   * @param {Object} o the options of the file
   * @return {Object} the new file.
   */
   var fileAdd = function (name, data, o) {
      // be sure sub folders exist
      var parent = parentFolder(name);
      if (parent) {
         folderAdd.call(this, parent);
      }

      o = prepareFileAttrs(o);

      if (o.dir || data === null || typeof data === "undefined") {
         o.base64 = false;
         o.binary = false;
         data = null;
      } else if (JSZip.support.uint8array && data instanceof Uint8Array) {
         o.base64 = false;
         o.binary = true;
         data = JSZip.utils.uint8Array2String(data);
      } else if (JSZip.support.arraybuffer && data instanceof ArrayBuffer) {
         o.base64 = false;
         o.binary = true;
         var bufferView = new Uint8Array(data);
         data = JSZip.utils.uint8Array2String(bufferView);
      } else if (o.binary && !o.base64) {
         // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask
         if (o.optimizedBinaryString !== true) {
            // this is a string, not in a base64 format.
            // Be sure that this is a correct "binary string"
            data = JSZip.utils.string2binary(data);
         }
         // we remove this option since it's only relevant here
         delete o.optimizedBinaryString;
      }

      return this.files[name] = new ZipObject(name, data, o);
   };


   /**
    * Find the parent folder of the path.
    * @private
    * @param {string} path the path to use
    * @return {string} the parent folder, or ""
    */
   var parentFolder = function (path) {
      if (path.slice(-1) == '/') {
         path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf('/');
      return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
   };

   /**
    * Add a (sub) folder in the current folder.
    * @private
    * @param {string} name the folder's name
    * @return {Object} the new folder.
    */
   var folderAdd = function (name) {
      // Check the name ends with a /
      if (name.slice(-1) != "/") {
         name += "/"; // IE doesn't like substr(-1)
      }

      // Does this folder already exist?
      if (!this.files[name]) {
         // be sure sub folders exist
         var parent = parentFolder(name);
         if (parent) {
            folderAdd.call(this, parent);
         }

         fileAdd.call(this, name, null, {dir:true});
      }
      return this.files[name];
   };

   /**
    * Generate the data found in the local header of a zip file.
    * Do not create it now, as some parts are re-used later.
    * @private
    * @param {Object} file the file to use.
    * @param {string} utfEncodedFileName the file name, utf8 encoded.
    * @param {string} compressionType the compression to use.
    * @return {Object} an object containing header and compressedData.
    */
   var prepareLocalHeaderData = function(file, utfEncodedFileName, compressionType) {
      var useUTF8 = utfEncodedFileName !== file.name,
          data    = file.asBinary(),
          o       = file.options,
          dosTime,
          dosDate;

      // date
      // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
      // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
      // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

      dosTime = o.date.getHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | o.date.getMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | o.date.getSeconds() / 2;

      dosDate = o.date.getFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | (o.date.getMonth() + 1);
      dosDate = dosDate << 5;
      dosDate = dosDate | o.date.getDate();

      var hasData = data !== null && data.length !== 0;

      compressionType = o.compression || compressionType;
      if (!JSZip.compressions[compressionType]) {
         throw compressionType + " is not a valid compression method !";
      }

      var compression    = JSZip.compressions[compressionType];
      var compressedData = hasData ? compression.compress(data) : '';

      var header = "";

      // version needed to extract
      header += "\x0A\x00";
      // general purpose bit flag
      // set bit 11 if utf8
      header += useUTF8 ? "\x00\x08" : "\x00\x00";
      // compression method
      header += hasData ? compression.magic : JSZip.compressions['STORE'].magic;
      // last mod file time
      header += decToHex(dosTime, 2);
      // last mod file date
      header += decToHex(dosDate, 2);
      // crc-32
      header += hasData ? decToHex(this.crc32(data), 4) : '\x00\x00\x00\x00';
      // compressed size
      header += hasData ? decToHex(compressedData.length, 4) : '\x00\x00\x00\x00';
      // uncompressed size
      header += hasData ? decToHex(data.length, 4) : '\x00\x00\x00\x00';
      // file name length
      header += decToHex(utfEncodedFileName.length, 2);
      // extra field length
      header += "\x00\x00";

      return {
         header:header,
         compressedData:compressedData
      };
   };


   // return the actual prototype of JSZip
   return {
      /**
       * Read an existing zip and merge the data in the current JSZip object.
       * The implementation is in jszip-load.js, don't forget to include it.
       * @param {String|ArrayBuffer|Uint8Array} stream  The stream to load
       * @param {Object} options Options for loading the stream.
       *  options.base64 : is the stream in base64 ? default : false
       * @return {JSZip} the current JSZip object
       */
      load : function (stream, options) {
         throw new Error("Load method is not defined. Is the file jszip-load.js included ?");
      },

      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter : function (search) {
         var result = [], filename, relativePath, file, fileClone;
         for (filename in this.files) {
            if ( !this.files.hasOwnProperty(filename) ) { continue; }
            file = this.files[filename];
            // return a new object, don't let the user mess with our internal objects :)
            fileClone = new ZipObject(file.name, file.data, extend(file.options));
            relativePath = filename.slice(this.root.length, filename.length);
            if (filename.slice(0, this.root.length) === this.root && // the file is in the current root
                search(relativePath, fileClone)) { // and the file matches the function
               result.push(fileClone);
            }
         }
         return result;
      },

      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file : function(name, data, o) {
         if (arguments.length === 1) {
            if (name instanceof RegExp) {
               var regexp = name;
               return this.filter(function(relativePath, file) {
                  return !file.options.dir && regexp.test(relativePath);
               });
            } else { // text
               return this.filter(function (relativePath, file) {
                  return !file.options.dir && relativePath === name;
               })[0]||null;
            }
         } else { // more than one argument : we have data !
            name = this.root+name;
            fileAdd.call(this, name, data, o);
         }
         return this;
      },

      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder : function(arg) {
         if (!arg) {
            return this;
         }

         if (arg instanceof RegExp) {
            return this.filter(function(relativePath, file) {
               return file.options.dir && arg.test(relativePath);
            });
         }

         // else, name is a new folder
         var name = this.root + arg;
         var newFolder = folderAdd.call(this, name);

         // Allow chaining by returning a new object with this folder as the root
         var ret = this.clone();
         ret.root = newFolder.name;
         return ret;
      },

      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {JSZip} this JSZip object
       */
      remove : function(name) {
         name = this.root + name;
         var file = this.files[name];
         if (!file) {
            // Look for any folders
            if (name.slice(-1) != "/") {
               name += "/";
            }
            file = this.files[name];
         }

         if (file) {
            if (!file.options.dir) {
               // file
               delete this.files[name];
            } else {
               // folder
               var kids = this.filter(function (relativePath, file) {
                  return file.name.slice(0, name.length) === name;
               });
               for (var i = 0; i < kids.length; i++) {
                  delete this.files[kids[i].name];
               }
            }
         }

         return this;
      },

      /**
       * Generate the complete zip file
       * @param {Object} options the options to generate the zip file :
       * - base64, (deprecated, use type instead) true to generate base64.
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {String|Uint8Array|ArrayBuffer|Blob} the zip file
       */
      generate : function(options) {
         options = extend(options || {}, {
            base64 : true,
            compression : "STORE",
            type : "base64"
         });
         var compression = options.compression.toUpperCase();

         if (!JSZip.compressions[compression]) {
            throw compression + " is not a valid compression method !";
         }

         // The central directory, and files data
         var directory = [], files = [], fileOffset = 0;

         for (var name in this.files) {
            if ( !this.files.hasOwnProperty(name) ) { continue; }

            var file = this.files[name];

            var utfEncodedFileName = this.utf8encode(file.name);

            var fileRecord = "",
            dirRecord = "",
            data = prepareLocalHeaderData.call(this, file, utfEncodedFileName, compression);
            fileRecord = JSZip.signature.LOCAL_FILE_HEADER + data.header + utfEncodedFileName + data.compressedData;

            dirRecord = JSZip.signature.CENTRAL_FILE_HEADER +
            // version made by (00: DOS)
            "\x14\x00" +
            // file header (common to file and central directory)
            data.header +
            // file comment length
            "\x00\x00" +
            // disk number start
            "\x00\x00" +
            // internal file attributes TODO
            "\x00\x00" +
            // external file attributes
            (this.files[name].options.dir===true?"\x10\x00\x00\x00":"\x00\x00\x00\x00")+
            // relative offset of local header
            decToHex(fileOffset, 4) +
            // file name
            utfEncodedFileName;

            fileOffset += fileRecord.length;

            files.push(fileRecord);
            directory.push(dirRecord);
         }

         var fileData = files.join("");
         var dirData = directory.join("");

         var dirEnd = "";

         // end of central dir signature
         dirEnd = JSZip.signature.CENTRAL_DIRECTORY_END +
         // number of this disk
         "\x00\x00" +
         // number of the disk with the start of the central directory
         "\x00\x00" +
         // total number of entries in the central directory on this disk
         decToHex(files.length, 2) +
         // total number of entries in the central directory
         decToHex(files.length, 2) +
         // size of the central directory   4 bytes
         decToHex(dirData.length, 4) +
         // offset of start of central directory with respect to the starting disk number
         decToHex(fileData.length, 4) +
         // .ZIP file comment length
         "\x00\x00";

         var zip = fileData + dirData + dirEnd;


         switch(options.type.toLowerCase()) {
            case "uint8array" :
               return JSZip.utils.string2Uint8Array(zip);
            case "arraybuffer" :
               return JSZip.utils.string2Uint8Array(zip).buffer;
            case "blob" :
               return JSZip.utils.string2Blob(zip);
            case "base64" :
               return (options.base64) ? JSZipBase64.encode(zip) : zip;
            default : // case "string" :
               return zip;
         }
      },

      /**
       *
       *  Javascript crc32
       *  http://www.webtoolkit.info/
       *
       */
      crc32 : function(str, crc) {

         if (str === "" || typeof str === "undefined") {
            return 0;
         }

         var table = [
            0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
            0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
            0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
            0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
            0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
            0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
            0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
            0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
            0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
            0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
            0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
            0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
            0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
            0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
            0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
            0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
            0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
            0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
            0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
            0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
            0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
            0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
            0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
            0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
            0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
            0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
            0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
            0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
            0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
            0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
            0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
            0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
            0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
            0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
            0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
            0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
            0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
            0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
            0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
            0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
            0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
            0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
            0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
            0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
            0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
            0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
            0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
            0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
            0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
            0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
            0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
            0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
            0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
            0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
            0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
            0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
            0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
            0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
            0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
            0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
            0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
            0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
            0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
            0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
         ];

         if (typeof(crc) == "undefined") { crc = 0; }
         var x = 0;
         var y = 0;

         crc = crc ^ (-1);
         for( var i = 0, iTop = str.length; i < iTop; i++ ) {
            y = ( crc ^ str.charCodeAt( i ) ) & 0xFF;
            x = table[y];
            crc = ( crc >>> 8 ) ^ x;
         }

         return crc ^ (-1);
      },

      // Inspired by http://my.opera.com/GreyWyvern/blog/show.dml/1725165
      clone : function() {
         var newObj = new JSZip();
         for (var i in this) {
            if (typeof this[i] !== "function") {
               newObj[i] = this[i];
            }
         }
         return newObj;
      },


      /**
       * http://www.webtoolkit.info/javascript-utf8.html
       */
      utf8encode : function (string) {
         var utftext = "";

         for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
               utftext += String.fromCharCode(c);
            } else if ((c > 127) && (c < 2048)) {
               utftext += String.fromCharCode((c >> 6) | 192);
               utftext += String.fromCharCode((c & 63) | 128);
            } else {
               utftext += String.fromCharCode((c >> 12) | 224);
               utftext += String.fromCharCode(((c >> 6) & 63) | 128);
               utftext += String.fromCharCode((c & 63) | 128);
            }

         }

         return utftext;
      },

      /**
       * http://www.webtoolkit.info/javascript-utf8.html
       */
      utf8decode : function (utftext) {
         var string = "";
         var i = 0;
         var c = 0, c1 = 0, c2 = 0, c3 = 0;

         while ( i < utftext.length ) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
               string += String.fromCharCode(c);
               i++;
            } else if ((c > 191) && (c < 224)) {
               c2 = utftext.charCodeAt(i+1);
               string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
               i += 2;
            } else {
               c2 = utftext.charCodeAt(i+1);
               c3 = utftext.charCodeAt(i+2);
               string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
               i += 3;
            }

         }

         return string;
      }
   };
}());

/*
 * Compression methods
 * This object is filled in as follow :
 * name : {
 *    magic // the 2 bytes indentifying the compression method
 *    compress // function, take the uncompressed content and return it compressed.
 *    uncompress // function, take the compressed content and return it uncompressed.
 * }
 *
 * STORE is the default compression method, so it's included in this file.
 * Other methods should go to separated files : the user wants modularity.
 */
JSZip.compressions = {
   "STORE" : {
      magic : "\x00\x00",
      compress : function (content) {
         return content; // no compression
      },
      uncompress : function (content) {
         return content; // no compression
      }
   }
};

/*
 * List features that require a modern browser, and if the current browser support them.
 */
JSZip.support = {
   // contains true if JSZip can read/generate ArrayBuffer, false otherwise.
   arraybuffer : (function(){
      return typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
   })(),
   // contains true if JSZip can read/generate Uint8Array, false otherwise.
   uint8array : (function(){
      return typeof Uint8Array !== "undefined";
   })(),
   // contains true if JSZip can read/generate Blob, false otherwise.
   blob : (function(){
      // the spec started with BlobBuilder then replaced it with a construtor for Blob.
      // Result : we have browsers that :
      // * know the BlobBuilder (but with prefix)
      // * know the Blob constructor
      // * know about Blob but not about how to build them
      // About the "=== 0" test : if given the wrong type, it may be converted to a string.
      // Instead of an empty content, we will get "[object Uint8Array]" for example.
      if (typeof ArrayBuffer === "undefined") {
         return false;
      }
      var buffer = new ArrayBuffer(0);
      try {
         return new Blob([buffer], { type: "application/zip" }).size === 0;
      }
      catch(e) {}

      try {
         var builder = new (window.BlobBuilder || window.WebKitBlobBuilder ||
                            window.MozBlobBuilder || window.MSBlobBuilder)();
         builder.append(buffer);
         return builder.getBlob('application/zip').size === 0;
      }
      catch(e) {}

      return false;
   })()
};

JSZip.utils = {
   /**
    * Convert a string to a "binary string" : a string containing only char codes between 0 and 255.
    * @param {string} str the string to transform.
    * @return {String} the binary string.
    */
   string2binary : function (str) {
      var result = "";
      for (var i = 0; i < str.length; i++) {
         result += String.fromCharCode(str.charCodeAt(i) & 0xff);
      }
      return result;
   },
   /**
    * Create a Uint8Array from the string.
    * @param {string} str the string to transform.
    * @return {Uint8Array} the typed array.
    * @throws {Error} an Error if the browser doesn't support the requested feature.
    */
   string2Uint8Array : function (str) {
      if (!JSZip.support.uint8array) {
         throw new Error("Uint8Array is not supported by this browser");
      }
      var buffer = new ArrayBuffer(str.length);
      var bufferView = new Uint8Array(buffer);
      for(var i = 0; i < str.length; i++) {
         bufferView[i] = str.charCodeAt(i);
      }

      return bufferView;
   },

   /**
    * Create a string from the Uint8Array.
    * @param {Uint8Array} array the array to transform.
    * @return {string} the string.
    * @throws {Error} an Error if the browser doesn't support the requested feature.
    */
   uint8Array2String : function (array) {
      if (!JSZip.support.uint8array) {
         throw new Error("Uint8Array is not supported by this browser");
      }
      var result = "";
      for(var i = 0; i < array.length; i++) {
         result += String.fromCharCode(array[i]);
      }

      return result;
   },
   /**
    * Create a blob from the given string.
    * @param {string} str the string to transform.
    * @return {Blob} the string.
    * @throws {Error} an Error if the browser doesn't support the requested feature.
    */
   string2Blob : function (str) {
      if (!JSZip.support.blob) {
         throw new Error("Blob is not supported by this browser");
      }

      var buffer = JSZip.utils.string2Uint8Array(str).buffer;
      try {
         // Blob constructor
         return new Blob([buffer], { type: "application/zip" });
      }
      catch(e) {}

      try {
         // deprecated, browser only, old way
         var builder = new (window.BlobBuilder || window.WebKitBlobBuilder ||
                            window.MozBlobBuilder || window.MSBlobBuilder)();
         builder.append(buffer);
         return builder.getBlob('application/zip');
      }
      catch(e) {}

      // well, fuck ?!
      throw new Error("Bug : can't construct the Blob.");
   }
};

/**
 *
 *  Base64 encode / decode
 *  http://www.webtoolkit.info/
 *
 *  Hacked so that it doesn't utf8 en/decode everything
 **/
var JSZipBase64 = (function() {
   // private property
   var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

   return {
      // public method for encoding
      encode : function(input, utf8) {
         var output = "";
         var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
         var i = 0;

         while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
               enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
               enc4 = 64;
            }

            output = output +
               _keyStr.charAt(enc1) + _keyStr.charAt(enc2) +
               _keyStr.charAt(enc3) + _keyStr.charAt(enc4);

         }

         return output;
      },

      // public method for decoding
      decode : function(input, utf8) {
         var output = "";
         var chr1, chr2, chr3;
         var enc1, enc2, enc3, enc4;
         var i = 0;

         input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

         while (i < input.length) {

            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output = output + String.fromCharCode(chr1);

            if (enc3 != 64) {
               output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
               output = output + String.fromCharCode(chr3);
            }

         }

         return output;

      }
   };
}());

// enforcing Stuk's coding style
// vim: set shiftwidth=3 softtabstop=3:


/* **********************************************
     Begin TextCleaner.js
********************************************** */

//NOTE: This file MUST be saved in Windows 1252 character encoding or else it WILL NOT WORK!!!

var TextCleaner = (function () {
	
	//List out the Windows1252 strinsg that are representative of UTF-8 strings
	var toReplace = ["â‚¬","Ã€","Ã","â€š","Ã‚","Æ’","Ãƒ","â€ž","Ã„","â€¦","Ã…","â€","Ã†","â€¡","Ã‡","Ë†","Ãˆ","â€°","Ã‰","Å","ÃŠ","â€¹","Ã‹","Å’","ÃŒ","Ã","Å½","ÃŽ","Ã","Ã","â€˜","Ã‘","â€™","Ã’","â€œ","Ã“","â€","Ã”","â€¢","Ã•","â€“","Ã–","â€”","Ã—","Ëœ","Ã˜","â„¢","Ã™","Å¡","Ãš","â€º","Ã›","Å“","Ãœ","Ã","Å¾","Ãž","Å¸","ÃŸ","Ã","Â¡","Ã¡","Â¢","Ã¢","Â£","Ã£","Â¤","Ã¤","Â¥","Ã¥","Â¦","Ã¦","Â§","Ã§","Â¨","Ã¨","Â©","Ã©","Âª","Ãª","Â«","Ã«","Â¬","Ã¬","Â­","Ã­","Â®","Ã®","Â¯","Ã¯","Â°","Ã°","Â±","Ã±","Â²","Ã²","Â³","Ã³","Â´","Ã´","Âµ","Ãµ","Â¶","Ã¶","Â·","Ã·","Â¸","Ã¸","Â¹","Ã¹","Âº","Ãº","Â»","Ã»","Â¼","Ã¼","Â½","Ã½","Â¾","Ã¾","Â¿","Ã¿"];
	
	//List out the UTF-8 string that we want to get back
	var replaceWith = ["€","À","Á","‚","Â","ƒ","Ã","„","Ä","…","Å","†","Æ","‡","Ç","ˆ","È","‰","É","Š","Ê","‹","Ë","Œ","Ì","Í","Ž","Î","Ï","Ð","‘","Ñ","’","Ò","“","Ó","”","Ô","•","Õ","–","Ö","—","×","˜","Ø","™","Ù","š","Ú","›","Û","œ","Ü","Ý","ž","Þ","Ÿ","ß","à","¡","á","¢","â","£","ã","¤","ä","¥","å","¦","æ","§","ç","¨","è","©","é","ª","ê","«","ë","¬","ì","­","í","®","î","¯","ï","°","ð","±","ñ","²","ò","³","ó","´","ô","µ","õ","¶","ö","·","÷","¸","ø","¹","ù","º","ú","»","û","¼","ü","½","ý","¾","þ","¿","ÿ"];
	
	//Create an object map to associate the two arrays so we can look up a string and find it's replacement
	var map = {};
	for (var i=0; i<toReplace.length; i++) {
		map[toReplace[i]] = replaceWith[i];
	}

	//Now that we have a map, let's sort the haystack from longerst to shortest
	toReplace.sort(function(a,b){
		return b.length - a.length;
	});

	//Build up a regular expression to find the strings to replace
	var expression = new RegExp(toReplace.join("|"), "g");

	//Public function to convert from win1252 to UTF-8
	function convertWin1252ToUtf8(source) {
		//Use teh RegEx to search the string for matches, then replace any of them with the corresponding replacement string
		return source.replace(expression, function(m) {
			return map[m] || "";
		});
	}

	return{
		ConvertWin1252ToUtf8: convertWin1252ToUtf8
	};
})();

/* **********************************************
     Begin formats.propresenter.js
********************************************** */

/*!
 * LICENSE:
 * CC BY-NC-SA 3.0
 * This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
 * http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US
 */

/*=====================================================
 * PARSER for ProPresenter 4 files
 * Extension: .pro4
 * Site: http://www.renewedvision.com/propresenter.php
=======================================================*/

(function () {

	var THIS_FORMAT = 'propresenter';
	parser.formats[THIS_FORMAT] = {};

	parser.formats[THIS_FORMAT].testExtension = function(fileExt){
		return /pro\d+/i.test(fileExt);
	};

	//Extend the formats object on the parser to allow for parsing ProPresenter files
	parser.formats[THIS_FORMAT].convert = function(songData, fileName){
		
		//select the top-level document element
		var $presentationDoc = $(songData);

		//Collect all the attributes to parse later
		var attrs = $presentationDoc.get(0).attributes;
			
		//Collect all the sides to parse later
		var $slides = $presentationDoc.children("slides").children();

		//Make sure the title is filled in, if not use the filename
		var songTitle = (typeof attrs.cclisongtitle === "string" && attrs.cclisongtitle.length > 0) ? attrs.cclisongtitle.value : fileName;

		//Fill in the filled-in song object
		return {
			title: songTitle,
			info: _getInfo(attrs),
			slides: _getSlides($slides)
		};
	};

	//===================================
	//PRIVATE FUNCTIONS
	//===================================
	function _getSlides($slides){
		var songSlides = [];

		//Loop through all the passed in slides
		$slides.each(function(i, el){
			var $thisSlide = $(el);

			var labelText = $.trim($thisSlide.attr("label"));

			//Grab the base64 encoded data from the slide element, decode it, the strip off the RTF formatting
			var encodedRtfData = $thisSlide.find("rvtextelement").attr("rtfdata");
			var decodedRtfData = parser.utilities.decode(encodedRtfData);
			var lyricsText = _stripRtf(decodedRtfData);

			songSlides.push({
				"title":labelText,
				"lyrics":lyricsText
			});
		});

		return songSlides;
	}

	function _getInfo(infoAttributes){
		//An array of attributes that we don't need to display in the UI
		var itemsToRemove = ['height','width','cclisongtitle','cclidisplay','versionnumber','doctype','creatorcode','lastdateused', 'usedcount','backgroundcolor','drawingbackgroundcolor'];

		var songInfo = [];

		//Loop through all the passed in attributes
		$.each(infoAttributes, function(i, thisAttr){

			//Continue only if the attribute is not in the array above AND the value is not blank
			if($.inArray(thisAttr.name, itemsToRemove) < 0 && thisAttr.value !== ""){
				songInfo.push({
					"name": thisAttr.name,
					"value": thisAttr.value
				});
			}
		});

		//Special case - Set the date. Parse it to a human readable date!
		var lastUsedDate = new Date(Date.parse(infoAttributes.lastdateused.value));
		if(!isNaN(lastUsedDate.getTime())){
			songInfo.push({
				"name": "Last Used On",
				"value":lastUsedDate
			});
		}

		return songInfo;
	}

	function _stripRtf(str){
		//var pattern = /\{\*?\\[^{}]+}|[{}]|\\\n?[A-Za-z]+\n?(?:-?\d+)?[ ]?/g;
		var basicRtfPattern = /\{\*?\\[^{}]+}|[{}]|\\[A-Za-z]+\n?(?:-?\d+)?[ ]?/g;
		var newLineSlashesPattern = /\\\n/g;

		var stripped = str.replace(basicRtfPattern,"");
		var removeNewlineSlashes = stripped.replace(newLineSlashesPattern, "\n");
		var removeWhitespace = removeNewlineSlashes.trim();

		return removeWhitespace;
	}
})();

/* **********************************************
     Begin formats.songshowplus.js
********************************************** */

/*=====================================================
 * PARSER for SongShowPlus files
 * Extension: .sbsong
 * Site: http://www.songshowplus.com/
 * NOTE: This file MUST be saved in Windows 1252 character encoding or else it WILL NOT properly make use of the TextConverter!!!
=======================================================*/

(function () {

	var THIS_FORMAT = 'songshowplus';
	parser.formats[THIS_FORMAT] = {};

	parser.formats[THIS_FORMAT].testExtension = function(fileExt){
		return /sbsong/i.test(fileExt);
	};

	//Extend the formats object on the parser to allow for parsing SongShowPlus files
	parser.formats[THIS_FORMAT].convert = function(songData, fileName){
		//We don't want any properties XML tags which can sometimes begin the file.
		//Splitting these out and then taking teh first array item can prevent this.
		//Each song sections seems to be split up by a percent sign, so make an array by splitting on that
		var sections = songData.split("<Properties>")[0].split("%");

		//Pass all the sections in here to get the lyrics
		//We will get out the slides and the keywords
		var slideContent = _getSlides(sections);

		//The info is all contained in the first section, so only pass that in and pass in teh keywords from above
		var parsedInfo = _getInfo(sections[0], slideContent.keywords, fileName);

		//Return the filled in song object
		return {
			title: parsedInfo.title,
			info: parsedInfo.info,
			slides: slideContent.slides
		};
	};

	//===================================
	//PRIVATE FUNCTIONS
	//===================================

	//Regex pattern AS A STRING to match invisible control characters
	//Slashes are double escaped here so it can be in a string!
	var _patternInvisiblesStr = "[\\xA0\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F]";
	//Same pattern, but as a real RexExp object
	var _invisibles = new RegExp(_patternInvisiblesStr);

	function _getInfo (firstSection, keywords, fileName) {
		//Split the info up into an array by the invisible characters
		var infoArray = firstSection.split(_invisibles);
		
		//Now loop through the array and remove all empty items and items that are only 1 character long
		infoArray = $.grep(infoArray,function(n){
			var item = $.trim(n).replace(/\r\n\t/g,"");
			return item.length>1 ? item : false;
		});

		//If the first items is a number between 1 and 4 digits, remove it
		if(/[0-9]{1,4}/.test(infoArray[0])){
			infoArray.splice(0,1);
		}

		//Make sure the title is filled in, if not use the filename
		var songTitle = (infoArray.length > 0 && infoArray[0].length > 0) ? infoArray[0] : fileName;
		
		//remove leading dollar signs for whatever reason...
		songTitle = songTitle.indexOf("$")===1 ? songTitle.substring(1,songTitle.length) : songTitle;
		
		//remove trailing dollar signs for whatever reason...
		songTitle = songTitle.substring(0, songTitle.length - +(songTitle.lastIndexOf('$')==songTitle.length-1));
		
		var songInfo = [];
		
		if(infoArray[1]){
			songInfo.push({
				'name':'Artist/Author',
				'value':infoArray[1]
			});
		}
		
		//If the copyright exists, add it
		if(infoArray[2]){
			songInfo.push({
				'name':'Copyright',
				'value':infoArray[2].replace("$","") //copyright info tends to end with a $ sign, so remove it
			});
		}

		//If the CCLI exists, add it
		if(infoArray[3]){
			songInfo.push({
				'name':'CCLI',
				'value':infoArray[3]
			});
		}

		//If we have keywords, add them
		if(keywords){
			songInfo.push({
				'name':'Keywords',
				'value':keywords
			});
		}

		//Convert characters as needed - useful for non-english alphabets (Spanish)
		songTitle = TextCleaner.ConvertWin1252ToUtf8(songTitle);
		for (var i = 0; i < songInfo.length; i++) {
			songInfo[i].value = TextCleaner.ConvertWin1252ToUtf8(songInfo[i].value);
		};

		return {
			'info': songInfo,
			'title': songTitle
		};
	}

	function _getSlides (sections) {
		//Sections tend to begin with N number of control characters, a random print character, more control characters, and then the title "Verse 1" or something
		//After that is the actual song lyrics, but it may be preceeded by one non-word character
		//Slashes are double escaped here so it can be in a string!
		var slidePattern = new RegExp("^" + _patternInvisiblesStr + "+.{1}" + _patternInvisiblesStr + "+(.+)" + _patternInvisiblesStr + "+\\W*([\\s\\S]+)", "m");

		var slideArray = [];

		//Loop through the sections, but SKIP the first one since it contains the song info we don't need here
		for (var i = 1; i < sections.length; i++) {
			
			//Run the regex on each section to split out the slide title from the lyrics
			var matches = sections[i].match(slidePattern);

			//Remove whitespace from the title
			var slideTitle = (matches !== null && matches[1]) ? $.trim(matches[1].replace(_invisibles, "")) : "";

			//Remove any more invisibles from the lyrics and remove whitespace
			var slideLyrics = (matches !== null && matches[2]) ? $.trim(matches[2].replace(_invisibles, "")) : "";

			//Convert characters as needed - useful for non-english alphabets (Spanish)
			slideTitle = TextCleaner.ConvertWin1252ToUtf8(slideTitle);
			slideLyrics = TextCleaner.ConvertWin1252ToUtf8(slideLyrics);

			//Replace multiple slashes sometimes?
			slideLyrics = slideLyrics.replace(/\/+/g,"");

			//Save it to the array!
			slideArray.push({
				"title": slideTitle,
				"lyrics": slideLyrics
			});
		}

		//The last slide also contains the keywords, we need to parse these out separately
		var lastSlideObj = _getKeywordsFromLastSlide(sections.slice(-1)[0]);
		var keywords = false;
		if(lastSlideObj){

			//If we have no slides, and what we think are keywords are longer than the lyrics...
			//Then we might need to switch them for some reason...
			if(slideArray.length === 0 && lastSlideObj.keywords.length > lastSlideObj.lastLyrics.length){
				keywords = lastSlideObj.lastLyrics;
				slideArray.push({
					"title": "",
					"lyrics": lastSlideObj.keywords.replace(/\/+/g,"")
				});
			}else{
				keywords = lastSlideObj.keywords;
				if(slideArray.length > 0){
					slideArray.slice(-1)[0].lyrics = lastSlideObj.lastLyrics;
				}else{
					slideArray.push({
						"title": "",
						"lyrics": lastSlideObj.lastLyrics.replace(/\/+/g,"")
					});
				}
			}
		}

		return {
			'slides': slideArray,
			'keywords': keywords
		};
	}

	function _getKeywordsFromLastSlide(lastSlideRaw) {

		var infoArray = lastSlideRaw.split(_invisibles);
		//Now loop through the array and remove all empty items and items that are only 1 character long
		infoArray = $.grep(infoArray,function(n){
			var item = $.trim(n);
			return item.length>1 ? item : false;
		});

		//If we have at least 3 sections, then we have keywords
		if(infoArray.length>2){
			//The keywords are the entire array except for the first two items
			var keywords = infoArray.splice(2).join(", ").replace(/\r\n\t/g,"");

			//Return the last slide minus the keywords, then parse out the optional begining non-word character
			var lastLyrics = infoArray[1].match(/^\W*([\s\S]+)/m)[1];

			//Convert characters as needed - useful for non-english alphabets (Spanish)
			keywords = TextCleaner.ConvertWin1252ToUtf8(keywords);
			lastLyrics = TextCleaner.ConvertWin1252ToUtf8(lastLyrics);

			return{
				'keywords': keywords,
				'lastLyrics': lastLyrics
			};
		}

		//We have nothing to return!
		return false;
		
	}
})();

/* **********************************************
     Begin outputs.propresenter.js
********************************************** */

/*!
 * LICENSE:
 * CC BY-NC-SA 3.0
 * This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
 * http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US
 */
 

/*=====================================================
 * OUTPUT for converting to ProPresenter format
=======================================================*/

(function(){
	var THIS_OUTPUT = 'propresenter';
	var FILE_EXTENSION = ".pro4";

	//Extend the outputs object on the parser to allow for HTML output
	parser.outputs[THIS_OUTPUT] = function ($container, songList) {

		//Loop through and convert each file and add the 
		var convertedFileContents=[];
		var errorFiles = [];
		$.each(songList, function(i, song) {
			try{
				convertedFileContents.push({
					name: song.name,
					data: _makeProPresenterFile(song.data)
				});
			}catch(ex){
				errorFiles.push(song.name);
			}
		});

		//Display any errors if we have them
		if(errorFiles.length){
			parser.displayError(errorFiles.join(", "), "Error converting the following " + errorFiles.length + " songs!");
		}

		_displaySuccessHtml($container, convertedFileContents);
	}

	//===================================
	//PRIVATE FUNCTIONS
	//===================================
	function _makeProPresenterFile(songData){
		
		var ppDoc = _getPPDocBegin(songData);

		for (var i = 0; i < songData.slides.length; i++) {
			var slide = songData.slides[i];

			ppDoc += _makeSlide(i, slide.title, slide.lyrics);
		};

		ppDoc += '</slides><timeline timeOffSet="0" selectedMediaTrackIndex="0" unitOfMeasure="60" duration="0" loop="0"><timeCues containerClass="NSMutableArray"></timeCues><mediaTracks containerClass="NSMutableArray"></mediaTracks></timeline><bibleReference containerClass="NSMutableDictionary"></bibleReference></RVPresentationDocument>';;

		return ppDoc;

	}

	function _getPPDocBegin(songData){
		var keywords = '';
		var artist = '';
		var author = '';
		var year = '';
		var copyright = '';
		var ccli = '';

		var now = new Date();
		var todaysDate = now.getFullYear()+"-"+now.getMonth()+"-"+now.getDate()+"T"+now.getHours()+":"+now.getMinutes()+":"+now.getSeconds();

		//Loop through each info item and fill in the correct value if it exists
		for (var i = 0; i < songData.info.length; i++) {
			var info = songData.info[i];

			if(/copyright/i.test(info.name)){
				var ccMatches = info.value.match(/(\d{4})(.*)/);
				if(ccMatches){
					if(ccMatches.length>1) year = ccMatches[1];
					if(ccMatches.length>2) copyright = ccMatches[2];
				}else{
					copyright = info.value;
				}
			}else if(/ccli/i.test(info.name)){
				ccli = info.value;
			}else if(/keywords/i.test(info.name)){
				keywords = info.value;
			}else if(/author|artist/i.test(info.name)){
				artist = info.value;
				author = info.value;
			}
		};

		//Return the document beginning stringnew 
		return '<RVPresentationDocument height="768" width="1024" versionNumber="400" docType="0" creatorCode="1349676880" lastDateUsed="' + todaysDate + '" usedCount="0" category="Song" resourcesDirectory="" backgroundColor="0 0 0 1" drawingBackgroundColor="0" notes="' + keywords + '" artist="' + artist + '" author="' + author + '" album="" CCLIDisplay="0" CCLIArtistCredits="" CCLISongTitle="' + songData.title + '" CCLIPublisher="' + copyright + '" CCLICopyrightInfo="' + year + '" CCLILicenseNumber="' + ccli + '"><slides containerClass="NSMutableArray">';
	}

	function _generateUniqueID(){
		//Native PP ID Example: 26AAF905-8F45-4252-BFAB-4C10CCFE1476

		function s4() {
		  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
		};

		return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	}
	
	function _makeBlankSlide(order){
		return '<RVDisplaySlide backgroundColor="0 0 0 0" enabled="1" highlightColor="0 0 0 0" hotKey="" label="" notes="" slideType="1" sort_index="' + order + '" UUID="'+_generateUniqueID()+'" drawingBackgroundColor="0" serialization-array-index="' + order + '"><cues containerClass="NSMutableArray"></cues><displayElements containerClass="NSMutableArray"></displayElements></RVDisplaySlide>';
	}
	
	function _makeSlide(order, label, text){
		//Returns white Helvetica text in RTF format and then Base64 encoded
		//var fakeRTF="{\\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320{\\fonttbl\\f0\\fswiss\\fcharset0 Helvetica;}{\\colortbl;\\red255\\green255\blue255;}\pard\\tx560\\tx1120\\tx1680\\tx2240\\tx2800\\tx3360\\tx3920\\tx4480\\tx5040\\tx5600\\tx6160\\tx6720\qc\pardirnatural\\f0\\fs96 \cf1 "+ text.replace("\n","\\\n")+"}";

		var fakeRTF = ['{\\rtf1\\ansi\\ansicpg1252\\cocoartf1038\\cocoasubrtf320',
			'{\\fonttbl\\f0\\fswiss\\fcharset0 Helvetica;}',
			'{\\colortbl;\\red255\\green255\\blue255;}',
			'\\pard\\tx560\\tx1120\\tx1680\\tx2240\\tx2800\\tx3360\\tx3920\\tx4480\\tx5040\\tx5600\\tx6160\\tx6720\\qc\\pardirnatural',
			'',
			'\\f0\\fs96 \\cf1 '+ text.replace(/\r\n/g,"\\\n")+'}'].join("\n");

		var encodedRtf = parser.utilities.encode(fakeRTF)

		//console.log(encodedRtf);

		var slideXML = ['',
		'<RVDisplaySlide backgroundColor="0 0 0 0" enabled="1" highlightColor="0 0 0 0" hotKey="" label="' + label + '" notes="" slideType="1" sort_index="' + order + '" UUID="'+ _generateUniqueID() + '" drawingBackgroundColor="0" serialization-array-index="' + order+'">',
		'	<cues containerClass="NSMutableArray"></cues>',
		'	<displayElements containerClass="NSMutableArray">',
		'		<RVTextElement displayDelay="0" displayName="Default" locked="0" persistent="0" typeID="0" fromTemplate="0" bezelRadius="0" drawingFill="0" drawingShadow="0" drawingStroke="0" fillColor="1 1 1 1" rotation="0" source="" adjustsHeightToFit="0" verticalAlignment="0" RTFData="' + encodedRtf + '" serialization-array-index="0">',
		'			<_-RVRect3D-_position x="20" y="20" z="0" width="984" height="728"></_-RVRect3D-_position>',
		'			<_-D-_serializedShadow containerClass="NSMutableDictionary">',
		'				<NSCFNumber serialization-native-value="5" serialization-dictionary-key="shadowBlurRadius"></NSCFNumber>',
		'				<NSCalibratedRGBColor serialization-native-value="0 0 0 0.5" serialization-dictionary-key="shadowColor"></NSCalibratedRGBColor>',
		'				<NSCFString serialization-native-value="{3.53553, -3.53553}" serialization-dictionary-key="shadowOffset"></NSCFString>',
		'			</_-D-_serializedShadow>',
		'			<stroke containerClass="NSMutableDictionary">',
		'				<NSCachedRGBColor serialization-native-value="0 0 0 1" serialization-dictionary-key="RVShapeElementStrokeColorKey"></NSCachedRGBColor>',
		'				<NSCFNumber serialization-native-value="1" serialization-dictionary-key="RVShapeElementStrokeWidthKey"></NSCFNumber>',
		'			</stroke>',
		'		</RVTextElement>',
		'	</displayElements>',
		'</RVDisplaySlide>'].join("\n");

		return slideXML;
	}

	function _displaySuccessHtml($container, convertedFileContents){
		//Display any successes if we have them
		if(convertedFileContents.length > 0){
			//Make some unique ID's we can select on later
			var downloadZipId = "btn-"+THIS_OUTPUT+"-download-zip";
			var downloadFilesId = "btn-"+THIS_OUTPUT+"-download-files";

			//Build up some HTML to write out
			var finalHtml = "<h1>Converted " + convertedFileContents.length + " Song File" + (convertedFileContents.length>1?"s":"") + "!</h1>";
			if(convertedFileContents.length > 1){
				finalHtml += "<button id='"+downloadZipId+"' type='button' class='btn btn-large btn-primary'>Download as .zip</button>";	
				finalHtml += " or <button id='"+downloadFilesId+"' type='button' class='btn'>Download "+convertedFileContents.length + " individual files</button>";
			}else{
				finalHtml += "<button id='"+downloadFilesId+"' type='button' class='btn btn-large btn-primary'>Download file</button>";
			}
			
			//Write the HTML to the page
			$container.html(finalHtml);

			//Add click events to each button we added above
			$("#"+downloadZipId).on("click",function(){
				
				//Create a new .ZIP archive
				var zip = new JSZip();

				//Go through and add each fiel to the zip
				$.each(convertedFileContents, function(i, convertedSong) {
					zip.file(convertedSong.name + FILE_EXTENSION, convertedSong.data)
				});

				//Generate the zip file contents
				var zipContent = zip.generate({type:"blob"});
				//Download it!
				saveAs(zipContent, "converted files.zip");
			});

			$("#"+downloadFilesId).on("click",function(){
				$.each(convertedFileContents, function(i, convertedSong) {
					var fileBlob = new Blob([convertedSong.data], {type: "text/xml;charset=utf-8"});
					saveAs(fileBlob, convertedSong.name + FILE_EXTENSION);
				});
			});
		}
	}
})();

/* **********************************************
     Begin outputs.display.js
********************************************** */

/*!
 * LICENSE:
 * CC BY-NC-SA 3.0
 * This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
 * http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US
 */
 

/*=====================================================
 * OUTPUT for displaying slide content in the browser as HTML
=======================================================*/

(function(){
	var THIS_OUTPUT = 'display';

	//Extend the outputs object on the parser to allow for HTML output
	parser.outputs[THIS_OUTPUT] = function ($container, songList) {
		
		$.each(songList, function(i, song){
			//Create some slides with the normalized song data
			var $song = $(_createSlides(song.data))
			$container.append($song);

			//Now make all the slides have the same height
			_equalSlideHeights($song);
		});
	}

	//===================================
	//PRIVATE FUNCTIONS
	//===================================
	function _createSlides(songData){

		var htmlOutput = '<h3 class="song-title">'+songData.title+'</h3>';
		htmlOutput += '<ul class="song-info">';
		

		//Add each info item
		for (var i = 0; i < songData.info.length; i++) {
			var s = songData.info[i];
			htmlOutput += '<li><strong>'+s.name+':</strong> '+s.value+'</li>';
		};

		htmlOutput += '</ul><ul class="slides-container thumbnails">';

		//Output the slides themselves
		for (var i = 0; i < songData.slides.length; i++) {
			var s = songData.slides[i];
			//If the title is blank, add a space character so it look even
			var title = s.title.length < 1 ? '&nbsp;' : s.title;
			//Create a new HTML clide and add it to the DOM
			htmlOutput += '<li class="span3"><div class="thumbnail slide-content"><p class="slide-lyrics">'+s.lyrics+'</p><h6 class="slide-label">'+title+'</h6></div></li>';
		};

		htmlOutput += '</ul>'

		return htmlOutput;
	}

	function _equalSlideHeights($scope){
		var currentTallest = 0;

		$scope
			.find('.slide-lyrics')
			.each(function(i){
				if ($(this).height() > currentTallest) {
					currentTallest = $(this).height();
				}
			})
			.css({'min-height': currentTallest}); 
	}
})();